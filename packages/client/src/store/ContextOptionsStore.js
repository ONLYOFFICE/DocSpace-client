// (c) Copyright Ascensio System SIA 2009-2025
//
// This program is a free software product.
// You can redistribute it and/or modify it under the terms
// of the GNU Affero General Public License (AGPL) version 3 as published by the Free Software
// Foundation. In accordance with Section 7(a) of the GNU AGPL its Section 15 shall be amended
// to the effect that Ascensio System SIA expressly excludes the warranty of non-infringement of
// any third-party rights.
//
// This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For details, see
// the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
//
// You can contact Ascensio System SIA at Lubanas st. 125a-25, Riga, Latvia, EU, LV-1021.
//
// The  interactive user interfaces in modified source and object code versions of the Program must
// display Appropriate Legal Notices, as required under Section 5 of the GNU AGPL version 3.
//
// Pursuant to Section 7(b) of the License you must retain the original Product logo when
// distributing the program. Pursuant to Section 7(e) we decline to grant you any rights under
// trademark law for use of our trademarks.
//
// All the Product's GUI elements, including illustrations and icon sets, as well as technical writing
// content are licensed under the terms of the Creative Commons Attribution-ShareAlike 4.0
// International. See the License terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode

import FileActionsOwnerReactSvgUrl from "PUBLIC_DIR/images/file.actions.owner.react.svg?url";
import HistoryReactSvgUrl from "PUBLIC_DIR/images/history.react.svg?url";
import HistoryFinalizedReactSvgUrl from "PUBLIC_DIR/images/history-finalized.react.svg?url";
import MoveReactSvgUrl from "PUBLIC_DIR/images/icons/16/move.react.svg?url";
import BackupSvgUrl from "PUBLIC_DIR/images/icons/16/backup.svg?url";
import CheckBoxReactSvgUrl from "PUBLIC_DIR/images/check-box.react.svg?url";
import FolderReactSvgUrl from "PUBLIC_DIR/images/folder.react.svg?url";
import ReconnectSvgUrl from "PUBLIC_DIR/images/reconnect.svg?url";
import SettingsReactSvgUrl from "PUBLIC_DIR/images/icons/16/catalog.settings.react.svg?url";
import FolderLocationReactSvgUrl from "PUBLIC_DIR/images/folder.location.react.svg?url";
import TickRoundedSvgUrl from "PUBLIC_DIR/images/tick.rounded.svg?url";
import FavoritesReactSvgUrl from "PUBLIC_DIR/images/favorite.react.svg?url";
import FavoritesFillReactSvgUrl from "PUBLIC_DIR/images/favorite.fill.react.svg?url";
import DownloadReactSvgUrl from "PUBLIC_DIR/images/icons/16/download.react.svg?url";
import CircleCrossSvgUrl from "PUBLIC_DIR/images/icons/16/circle.cross.svg?url";
import DownloadAsReactSvgUrl from "PUBLIC_DIR/images/download-as.react.svg?url";
import RenameReactSvgUrl from "PUBLIC_DIR/images/rename.react.svg?url";
import RemoveSvgUrl from "PUBLIC_DIR/images/remove.svg?url";
import TrashReactSvgUrl from "PUBLIC_DIR/images/icons/16/trash.react.svg?url";
import LockedReactSvgUrl from "PUBLIC_DIR/images/icons/16/locked.react.svg?url";
import CopyReactSvgUrl from "PUBLIC_DIR/images/icons/16/copy.react.svg?url";
import DuplicateReactSvgUrl from "PUBLIC_DIR/images/icons/16/duplicate.react.svg?url";
import FormFillRectSvgUrl from "PUBLIC_DIR/images/form.fill.rect.svg?url";
import AccessEditReactSvgUrl from "PUBLIC_DIR/images/access.edit.react.svg?url";
import EyeReactSvgUrl from "PUBLIC_DIR/images/eye.react.svg?url";
import FormPlusReactSvgUrl from "PUBLIC_DIR/images/form.plus.react.svg?url";
import FormFileReactSvgUrl from "PUBLIC_DIR/images/form.file.react.svg?url";
import PersonReactSvgUrl from "PUBLIC_DIR/images/person.react.svg?url";
import InfoOutlineReactSvgUrl from "PUBLIC_DIR/images/info.outline.react.svg?url";
import PinReactSvgUrl from "PUBLIC_DIR/images/pin.react.svg?url";
import UnpinReactSvgUrl from "PUBLIC_DIR/images/unpin.react.svg?url";
import UnmuteReactSvgUrl from "PUBLIC_DIR/images/unmute.react.svg?url";
import MuteReactSvgUrl from "PUBLIC_DIR/images/icons/16/mute.react.svg?url";
import ShareReactSvgUrl from "PUBLIC_DIR/images/share.react.svg?url";
import InvitationLinkReactSvgUrl from "PUBLIC_DIR/images/invitation.link.react.svg?url";
import EditIndexReactSvgUrl from "PUBLIC_DIR/images/edit.index.react.svg?url";
import TabletLinkReactSvgUrl from "PUBLIC_DIR/images/tablet-link.react.svg?url";
import RoomArchiveSvgUrl from "PUBLIC_DIR/images/room.archive.svg?url";
import PluginActionsSvgUrl from "PUBLIC_DIR/images/plugin.actions.react.svg?url";
import LeaveRoomSvgUrl from "PUBLIC_DIR/images/logout.react.svg?url";
import CatalogRoomsReactSvgUrl from "PUBLIC_DIR/images/icons/16/catalog.rooms.react.svg?url";
import RemoveOutlineSvgUrl from "PUBLIC_DIR/images/remove.react.svg?url";
import ActionsDocumentsReactSvgUrl from "PUBLIC_DIR/images/actions.documents.react.svg?url";
import SpreadsheetReactSvgUrl from "PUBLIC_DIR/images/spreadsheet.react.svg?url";
import ActionsPresentationReactSvgUrl from "PUBLIC_DIR/images/actions.presentation.react.svg?url";
import FormReactSvgUrl from "PUBLIC_DIR/images/access.form.react.svg?url";
import FormBlankReactSvgUrl from "PUBLIC_DIR/images/form.blank.react.svg?url";
import CatalogFolderReactSvgUrl from "PUBLIC_DIR/images/icons/16/catalog.folder.react.svg?url";
import ActionsUploadReactSvgUrl from "PUBLIC_DIR/images/actions.upload.react.svg?url";
import PluginMoreReactSvgUrl from "PUBLIC_DIR/images/plugin.more.react.svg?url";
import CodeReactSvgUrl from "PUBLIC_DIR/images/code.react.svg?url";
import ClearTrashReactSvgUrl from "PUBLIC_DIR/images/clear.trash.react.svg?url";
import ExportRoomIndexSvgUrl from "PUBLIC_DIR/images/icons/16/export-room-index.react.svg?url";
import AccessNoneReactSvgUrl from "PUBLIC_DIR/images/access.none.react.svg?url";
import HelpCenterReactSvgUrl from "PUBLIC_DIR/images/help.center.react.svg?url";
import CustomFilterReactSvgUrl from "PUBLIC_DIR/images/icons/16/custom-filter.react.svg?url";
import ViewRowsReactSvgUrl from "PUBLIC_DIR/images/view-rows.react.svg?url";

import CreateTemplateSvgUrl from "PUBLIC_DIR/images/template.react.svg?url";
import CreateRoomReactSvgUrl from "PUBLIC_DIR/images/create.room.react.svg?url";
import TemplateGalleryReactSvgUrl from "PUBLIC_DIR/images/template.gallery.react.svg?url";

import { makeAutoObservable, runInAction } from "mobx";
import copy from "copy-to-clipboard";
import { isMobile, isTablet } from "react-device-detect";
import config from "PACKAGE_FILE";
import { Trans } from "react-i18next";
import { toastr } from "@docspace/shared/components/toast";

import {
  isMobile as isMobileUtils,
  isLockedSharedRoom,
  trimSeparator,
} from "@docspace/shared/utils";
import { getDefaultAccessUser } from "@docspace/shared/utils/getDefaultAccessUser";
import { copyShareLink as copyToBuffer } from "@docspace/shared/utils/copy";
import {
  canShowManageLink,
  copyShareLink,
} from "@docspace/shared/components/share/Share.helpers";

import { getGuidanceConfig } from "@docspace/shared/components/guidance/configs";

import {
  connectedCloudsTypeTitleTranslation,
  removeOptions,
} from "SRC_DIR/helpers/filesUtils";
import { getOAuthToken } from "@docspace/shared/utils/common";
import {
  RoomsType,
  Events,
  FolderType,
  UrlActionType,
  FilesSelectorFilterTypes,
  FilterType,
  FileExtensions,
  ShareAccessRights,
} from "@docspace/shared/enums";

import {
  formRoleMapping,
  getFileLink,
  getFolderLink,
  removeSharedFolderOrFile,
} from "@docspace/shared/api/files";

import { checkDialogsOpen } from "@docspace/shared/utils/checkDialogsOpen";
import { hasOwnProperty } from "@docspace/shared/utils/object";
import { createLoader } from "@docspace/shared/utils/createLoader";
import {
  FILLING_STATUS_ID,
  SHARED_WITH_ME_PATH,
} from "@docspace/shared/constants";
import {
  isFile as isFileUtil,
  isFolder as isFolderUtil,
  isRoom as isRoomUtil,
} from "@docspace/shared/utils/typeGuards";
import {
  getInfoPanelOpen,
  openMembersTab,
  openShareTab,
  setInfoPanelMobileHidden,
  setView,
  showInfoPanel,
} from "SRC_DIR/helpers/info-panel";
import { ShareLinkService } from "@docspace/shared/services/share-link.service";

const LOADER_TIMER = 500;
let loadingTime;
let timer;

const systemFolders = [
  FolderType.InProgress,
  FolderType.Done,
  FolderType.SubFolderDone,
  FolderType.SubFolderInProgress,
];

class ContextOptionsStore {
  settingsStore;

  dialogsStore;

  filesActionsStore;

  filesStore;

  mediaViewerDataStore;

  treeFoldersStore;

  uploadDataStore;

  versionHistoryStore;

  filesSettingsStore;

  selectedFolderStore;

  publicRoomStore;

  oformsStore;

  pluginStore;

  infoPanelStore;

  currentTariffStatusStore;

  currentQuotaStore;

  userStore;

  indexingStore;

  clientLoadingStore;

  linksIsLoading = false;

  guidanceStore;

  constructor(
    settingsStore,
    dialogsStore,
    filesActionsStore,
    filesStore,
    mediaViewerDataStore,
    treeFoldersStore,
    uploadDataStore,
    versionHistoryStore,
    filesSettingsStore,
    selectedFolderStore,
    publicRoomStore,
    oformsStore,
    pluginStore,
    infoPanelStore,
    currentTariffStatusStore,
    currentQuotaStore,
    userStore,
    indexingStore,
    clientLoadingStore,
    guidanceStore,
  ) {
    makeAutoObservable(this);
    this.settingsStore = settingsStore;
    this.dialogsStore = dialogsStore;
    this.filesActionsStore = filesActionsStore;
    this.filesStore = filesStore;
    this.mediaViewerDataStore = mediaViewerDataStore;
    this.treeFoldersStore = treeFoldersStore;
    this.uploadDataStore = uploadDataStore;
    this.versionHistoryStore = versionHistoryStore;
    this.filesSettingsStore = filesSettingsStore;
    this.selectedFolderStore = selectedFolderStore;
    this.publicRoomStore = publicRoomStore;
    this.oformsStore = oformsStore;
    this.pluginStore = pluginStore;
    this.infoPanelStore = infoPanelStore;
    this.currentTariffStatusStore = currentTariffStatusStore;
    this.currentQuotaStore = currentQuotaStore;
    this.userStore = userStore;
    this.indexingStore = indexingStore;
    this.clientLoadingStore = clientLoadingStore;
    this.guidanceStore = guidanceStore;
  }

  onOpenFolder = async (item, t) => {
    const { isExpiredLinkAsync } = this.filesActionsStore;

    if (
      item.external &&
      (item.isLinkExpired || (await isExpiredLinkAsync(item)))
    ) {
      const isRoom = isRoomUtil(item);

      const description = isRoom
        ? t("Common:RoomLinkExpired")
        : t("Common:FolderLinkExpired");

      const title = isRoom
        ? t("Common:RoomNotAvailable")
        : t("Common:FolderNotAvailable");

      return toastr.error(description, title);
    }

    if (isLockedSharedRoom(item))
      return this.dialogsStore.setPasswordEntryDialog(true, item);

    this.filesActionsStore.openLocationAction(item);
  };

  onClickLinkFillForm = (item) => {
    const isFormRoom =
      this.selectedFolderStore?.roomType === RoomsType.FormRoom ||
      this.selectedFolderStore?.parentRoomType === FolderType.FormRoom;

    if (
      !item.startFilling &&
      item.isPDFForm &&
      !isFormRoom &&
      !this.publicRoomStore.isPublicRoom &&
      item?.security?.Copy
    )
      return this.dialogsStore.setFillPDFDialogData(true, item);

    return this.gotoDocEditor(item, false, null, false, !isFormRoom);
  };

  onClickReconnectStorage = async (item, t) => {
    const { thirdPartyStore } = this.filesSettingsStore;

    const { openConnectWindow, connectItems } = thirdPartyStore;

    const {
      setRoomCreation,
      setConnectItem,
      setConnectDialogVisible,
      setIsConnectDialogReconnect,
      setSaveAfterReconnectOAuth,
    } = this.dialogsStore;

    setIsConnectDialogReconnect(true);

    setRoomCreation(true);

    const provider = connectItems.find(
      (connectItem) => connectItem.providerName === item.providerKey,
    );

    const itemThirdParty = {
      title: connectedCloudsTypeTitleTranslation(provider.providerName, t),
      customer_title: "NOTITLE",
      provider_key: provider.providerName,
      link: provider.oauthHref,
      provider_id: item.providerId,
    };

    if (provider.isOauth) {
      const authModal = window.open(
        "",
        t("Common:Authorization"),
        "height=600, width=1020",
      );
      await openConnectWindow(provider.providerName, authModal)
        .then(getOAuthToken)
        .then((token) => {
          authModal.close();
          setConnectItem({
            ...itemThirdParty,
            token,
          });

          setSaveAfterReconnectOAuth(true);
        })
        .catch((err) => {
          if (!err) return;
          toastr.error(err);
        });
    } else {
      setConnectItem(itemThirdParty);
      setConnectDialogVisible(true);
    }
  };

  onClickMakeForm = (item, t) => {
    const { setConvertPasswordDialogVisible, setFormCreationInfo } =
      this.dialogsStore;
    const { title, id, folderId, fileExst } = item;

    const newTitle =
      title.substring(0, title.length - fileExst.length) +
      this.filesSettingsStore.extsWebRestrictedEditing[0];

    this.uploadDataStore.copyAsAction(id, newTitle, folderId).catch((err) => {
      let errorMessage = "";
      if (typeof err === "object") {
        errorMessage =
          err?.response?.data?.error?.message ||
          err?.statusText ||
          err?.message ||
          "";
      } else {
        errorMessage = err;
      }

      if (errorMessage.indexOf("password") == -1) {
        toastr.error(errorMessage, t("Common:Warning"));
        return;
      }

      toastr.error(t("Translations:FileProtected"), t("Common:Warning"));
      setFormCreationInfo({
        newTitle,
        fromExst: fileExst,
        toExst: this.filesSettingsStore.extsWebRestrictedEditing[0],
        fileInfo: item,
      });
      setConvertPasswordDialogVisible(true);
    });
  };

  onClickSubmitToFormGallery = (item) => {
    if (item && !item.exst) {
      const splitTitle = item.title.split(".");
      item.title = splitTitle.slice(0, -1).join(".");
      item.exst = splitTitle.length !== 1 ? `.${splitTitle.at(-1)}` : null;
    }

    this.dialogsStore.setFormItem(item);
    this.dialogsStore.setSubmitToGalleryDialogVisible(true);
  };

  onOpenLocation = (item) => {
    this.filesActionsStore.checkAndOpenLocationAction(item);
  };

  onMoveAction = (item) => {
    const { id, isFolder } = this.selectedFolderStore;

    setInfoPanelMobileHidden(true);

    const isFolderActions = id === item?.id && isFolder === item?.isFolder;
    if (isFolderActions) {
      this.dialogsStore.setIsFolderActions(true);
    }

    this.dialogsStore.setMoveToPanelVisible(true);
  };

  onRestoreAction = () => {
    setInfoPanelMobileHidden(true);
    this.dialogsStore.setRestorePanelVisible(true);
  };

  onCopyAction = (item) => {
    const { id, isFolder } = this.selectedFolderStore;

    setInfoPanelMobileHidden(true);

    const isFolderActions = id === item?.id && isFolder === item?.isFolder;
    if (isFolderActions) {
      this.dialogsStore.setIsFolderActions(true);
    }

    this.dialogsStore.setCopyPanelVisible(true);
  };

  showVersionHistory = (id, security, requestToken) => {
    const { fetchFileVersions, setIsVerHistoryPanel } =
      this.versionHistoryStore;

    if (this.treeFoldersStore.isRecycleBinFolder) return;

    fetchFileVersions(`${id}`, security, requestToken);
    setIsVerHistoryPanel(true);
    setInfoPanelMobileHidden(true);
  };

  finalizeVersion = (id) => {
    this.filesActionsStore.finalizeVersionAction(id).catch((err) => {
      toastr.error(err);
    });
  };

  onClickFavorite = (e, items, t) => {
    const data = (e.currentTarget && e.currentTarget.dataset) || e;
    const { action } = data;

    this.filesActionsStore
      .setFavoriteAction(action, items)
      .then(() =>
        action === "mark"
          ? toastr.success(t("MarkedAsFavorite"))
          : toastr.success(t("RemovedFromFavorites")),
      )
      .catch((err) => toastr.error(err));
  };

  lockFile = (item, t) => {
    const { id, locked } = item;

    this.filesActionsStore
      .lockFileAction(id, !locked)
      .then(() =>
        locked
          ? toastr.success(t("Translations:FileUnlocked"))
          : toastr.success(t("Translations:FileLocked")),
      )
      .catch((err) => {
        toastr.error(err);
      });
  };

  onClickLinkForPortal = (item, t) => {
    const { fileExst, canOpenPlayer, webUrl, id } = item;

    const isFile = !!fileExst;
    copy(
      isFile
        ? canOpenPlayer
          ? `${window.location.href}&preview=${id}`
          : webUrl
        : `${window.location.origin + config.homepage}/filter?folder=${id}`, // TODO: Change url by category
    );

    toastr.success(t("Common:LinkCopySuccess"));
  };

  onCopyLink = async (item, t) => {
    const { shared, navigationPath } = this.selectedFolderStore;

    const isArchive = item.rootFolderType === FolderType.Archive;

    const { href } = item;
    const sharedItem = navigationPath.find((r) => r.shared);

    const isShared = shared || sharedItem || item.shared;

    const isSystemFolder = systemFolders.includes(item.type);

    if (this.publicRoomStore.isPublicRoom) {
      copyToBuffer(item.shortWebUrl);
      return toastr.success(t("Common:LinkCopySuccess"));
    }

    if (isShared && !isArchive && !isSystemFolder && item.canShare) {
      try {
        const itemLink = item.isFolder
          ? await getFolderLink(item.id)
          : await getFileLink(item.id);

        copyToBuffer(itemLink.sharedTo.shareLink);
        item.customFilterEnabled
          ? toastr.success(
              <Trans t={t} i18nKey="Common:LinkCopySuccessWithCustomFilter" />,
            )
          : toastr.success(t("Common:LinkCopySuccess"));
      } catch (error) {
        toastr.error(error);
      }
      return;
    }

    if (
      item.rootFolderType === FolderType.Recent ||
      item.rootFolderType === FolderType.SHARE
    ) {
      copy(item.webUrl);
      return toastr.success(t("Common:LinkCopySuccess"));
    }

    if (href) {
      copy(href);

      return toastr.success(t("Common:LinkCopySuccess"));
    }

    const { canConvert } = this.filesSettingsStore;

    const { getItemUrl } = this.filesStore;

    const needConvert = canConvert(item.fileExst);

    const canOpenPlayer =
      item.viewAccessibility?.ImageView || item.viewAccessibility?.MediaView;

    const url = getItemUrl(
      item.id,
      item.isRoom || item.isFolder,
      needConvert,
      canOpenPlayer,
    );

    copy(url);

    toastr.success(t("Common:LinkCopySuccess"));
  };

  onOpenEmbeddingSettings = async (item) => {
    const { setLinkParams, setEmbeddingPanelData } = this.dialogsStore;

    setLinkParams({
      item,
    });

    setEmbeddingPanelData({ visible: true, item });
  };

  onCreateAndCopySharedLink = async (item, t) => {
    const { isExpiredLinkAsync } = this.filesActionsStore;

    if (
      item.external &&
      (item.isLinkExpired || (await isExpiredLinkAsync(item)))
    )
      return toastr.error(
        t("Common:RoomLinkExpired"),
        t("Common:RoomNotAvailable"),
      );

    const primaryLink = await this.filesStore.getPrimaryLink(item.id);

    if (primaryLink) {
      copyShareLink(item, primaryLink, t, this.getManageLinkOptions(item));
      // copyShareLink(primaryLink.sharedTo.shareLink);
      // item.shared
      //   ? toastr.success(t("Common:LinkSuccessfullyCopied"))
      //   : toastr.success(t("Files:LinkSuccessfullyCreatedAndCopied"));

      this.publicRoomStore.setExternalLink(primaryLink);
    }
  };

  onClickLinkEdit = (item) => {
    const { setConvertItem, setConvertDialogVisible, setConvertDialogData } =
      this.dialogsStore;
    const canConvert =
      item.viewAccessibility?.MustConvert && item.security?.Convert;

    if (canConvert) {
      setConvertItem({ ...item, isOpen: true });
      setConvertDialogData({
        files: item,
      });
      setConvertDialogVisible(true);
    } else {
      this.gotoDocEditor(item, false, null, item.isPDFForm);
    }
  };

  onPreviewClick = (item) => {
    this.gotoDocEditor(item, true);
  };

  gotoDocEditor = (
    item,
    preview = false,
    shareKey = null,
    editForm = false,
    fillForm = false,
  ) => {
    const { id } = item;

    this.filesStore.openDocEditor(id, preview, shareKey, editForm, fillForm);
  };

  // isPwa = () => {
  //   return ["fullscreen", "standalone", "minimal-ui"].some(
  //     (displayMode) =>
  //       window.matchMedia("(display-mode: " + displayMode + ")").matches,
  //   );
  // };

  onRemoveSharedFilesOrFolder = async (items) => {
    if (!Array.isArray(items) || items.length === 0) return;

    const { addActiveItems } = this.filesStore;
    const { setGroupMenuBlocked } = this.filesActionsStore;
    // const { clearActiveOperations } = this.uploadDataStore;

    const { folderIds, fileIds } = items.reduce(
      (acc, item) => {
        if (isFolderUtil(item) || isRoomUtil(item)) acc.folderIds.push(item.id);
        else if (isFileUtil(item)) acc.fileIds.push(item.id);

        return acc;
      },
      { folderIds: [], fileIds: [] },
    );

    try {
      runInAction(() => {
        setGroupMenuBlocked(true);
        addActiveItems(fileIds, folderIds);
      });

      await removeSharedFolderOrFile(folderIds, fileIds);
    } catch (error) {
      console.error(error);
      toastr.error(error);
    } finally {
      runInAction(() => {
        setGroupMenuBlocked(false);
      });
    }
  };

  onClickDownload = (item, t) => {
    const { viewUrl, isFolder } = item;
    const isFile = !isFolder;

    const { openUrl } = this.settingsStore;
    const { downloadAction } = this.filesActionsStore;

    isFile
      ? openUrl(viewUrl, UrlActionType.Download)
      : downloadAction(t("Common:ArchivingData"), item).catch((err) =>
          toastr.error(err),
        );
  };

  onClickDownloadAs = () => {
    this.dialogsStore.setDownloadDialogVisible(true);
  };

  onSetUpCustomFilter = (item, t) => {
    this.filesActionsStore.changeCustomFilter(item, t);
  };

  onDuplicate = (item) => {
    if (item.isRoom && this.currentQuotaStore.isWarningRoomsDialog) {
      this.dialogsStore.setQuotaWarningDialogVisible(true);
      return;
    }

    this.filesActionsStore.duplicateAction(item);
  };

  onClickRename = (item) => {
    const event = new Event(Events.RENAME);

    event.item = item;

    window.dispatchEvent(event);
  };

  onChangeThirdPartyInfo = (providerKey) => {
    this.filesActionsStore.setThirdpartyInfo(providerKey);
  };

  onFillingStatus = (item) => {
    console.log(item);
    this.dialogsStore.setFillingStatusPanelVisible(true);
  };

  onClickStartFilling = (item, t) => {
    if (isMobile)
      return toastr.info(t("Common:MobileStartFillingPdfNotAvailableInfo"));

    const refPage = this.filesStore.openDocEditor(
      item.id,
      false,
      null,
      true,
      false,
    );

    if (refPage) refPage.sessionStorage.setItem(FILLING_STATUS_ID, "true");
  };

  onClickResetAndStartFilling = async (item) => {
    const { addActiveItems } = this.filesStore;
    const { clearActiveOperations } = this.uploadDataStore;
    const { setGroupMenuBlocked } = this.filesActionsStore;

    const { endLoader, startLoader } = createLoader();

    try {
      startLoader(() => {
        runInAction(() => {
          setGroupMenuBlocked(true);
          addActiveItems([item.id], null);
        });
      });

      await formRoleMapping({
        formId: item.id,
        roles: [],
      });
    } catch (error) {
      toastr.error(error);
      console.error(error);
    } finally {
      endLoader(() =>
        runInAction(() => {
          setGroupMenuBlocked(false);
          clearActiveOperations([item.id]);
        }),
      );
    }
  };

  onMediaFileClick = (fileId, item) => {
    const itemId = typeof fileId !== "object" ? fileId : item.id;
    this.mediaViewerDataStore.setMediaViewerData({ visible: true, id: itemId });
    this.mediaViewerDataStore.changeUrl(itemId);
  };

  onClickDeleteSelectedFolder = (t, isRoom) => {
    const { setIsFolderActions, setDeleteDialogVisible, setIsRoomDelete } =
      this.dialogsStore;
    const { confirmDelete } = this.filesSettingsStore;
    const { deleteAction, deleteRoomsAction } = this.filesActionsStore;
    const { id: selectedFolderId, getSelectedFolder } =
      this.selectedFolderStore;
    const { isThirdPartySelection, setBufferSelection } = this.filesStore;

    const selectedFolder = getSelectedFolder();

    setIsFolderActions(true);

    if (confirmDelete || isThirdPartySelection) {
      setBufferSelection(selectedFolder);
      setIsRoomDelete(isRoom);
      setDeleteDialogVisible(true);

      return;
    }

    let translations;

    if (isRoom) {
      translations = {
        successRemoveRoom: t("Files:RoomRemoved"),
        successRemoveRooms: t("Files:RoomsRemoved"),
      };

      deleteRoomsAction([selectedFolderId], translations).catch((err) =>
        toastr.error(err),
      );
    } else {
      translations = {
        deleteFromTrash: t("Translations:TrashItemsDeleteSuccess", {
          sectionName: t("Common:TrashSection"),
        }),
      };

      deleteAction(translations, [selectedFolder], true).catch((err) =>
        toastr.error(err),
      );
    }
  };

  onClickDelete = (item, t) => {
    const { id, title, providerKey, isFolder, isRoom } = item;

    if (id === this.selectedFolderStore.id && isFolder) {
      this.onClickDeleteSelectedFolder(t, isRoom);

      return;
    }

    this.filesActionsStore.deleteItemAction(
      id,
      title,
      {},
      !isFolder,
      providerKey,
      isRoom,
    );
  };

  onClickShare = () => {
    // const { setShareFolderDialogVisible } = this.dialogsStore;

    openShareTab();
    // if (item.isFolder) {
    //   setShareFolderDialogVisible(true);
    // } else {
    // openShareTab();
    // }
  };

  onClickMarkRead = (item) => {
    const { markAsRead } = this.filesActionsStore;

    item.fileExst
      ? markAsRead([], [item.id], item)
      : markAsRead([item.id], [], item);
  };

  onClickUnsubscribe = () => {
    const { setDeleteDialogVisible, setUnsubscribe } = this.dialogsStore;

    setUnsubscribe(true);
    setDeleteDialogVisible(true);
  };

  onOpenPDFEditDialog = (id) => {
    this.filesStore.openDocEditor(id, false, null, true);
  };

  /**
   * @param {import("@docspace/shared/api/files/types").TFile} item - The item to delete.
   * @param {import("@docspace/shared/types").TTranslation} t - The translation function.
   * @returns {void}
   */
  onDelete = (item, t) => {
    const { isGroupMenuBlocked } = this.filesActionsStore;

    if (item.isEditing) return this.onShowEditingToast(t);

    if (isGroupMenuBlocked) return this.onShowWaitOperationToast(t);

    this.onClickDelete(item, t);
  };

  filterModel = (model, filter) => {
    const options = [];
    let index = 0;
    const last = model.length;

    for (index; index < last; index++) {
      if (filter.includes(model[index].key)) {
        options[index] = model[index];
        if (model[index].items) {
          options[index].items = model[index].items.filter((item) =>
            filter.includes(item.key),
          );

          if (options[index].items.length === 1) {
            options[index] = options[index].items[0];
          }
        }
      }
    }

    return options.filter((o) => !!o);
  };

  onShowInfoPanel = (item, view) => {
    showInfoPanel();

    if (item) {
      setView(view);
    }
  };

  onClickEditRoom = (item) => {
    const event = new Event(Events.ROOM_EDIT);
    event.item = item;
    window.dispatchEvent(event);
  };

  onSaveAsTemplate = (item) => {
    const event = new Event(Events.SAVE_AS_TEMPLATE);
    event.item = item;
    window.dispatchEvent(event);
  };

  onCreateRoomTemplate = (item) => {
    this.filesActionsStore.onCreateRoomFromTemplate(item);
  };

  onEditRoomTemplate = (item) => {
    const event = new Event(Events.ROOM_EDIT);
    event.item = { ...item, isEdit: true };
    window.dispatchEvent(event);
  };

  onOpenTemplateAccessOptions = () => {
    this.dialogsStore.setTemplateAccessSettingsVisible(true);
  };

  // onLoadLinks = async (t, item) => {
  //   const promise = new Promise(async (resolve, reject) => {
  //     let linksArray = [];

  //     this.setLoaderTimer(true);
  //     try {
  //       const links = await this.publicRoomStore.fetchExternalLinks(item.id);

  //       for (let link of links) {
  //         const { id, title, shareLink, disabled, isExpired } = link.sharedTo;

  //         if (!disabled && !isExpired) {
  //           linksArray.push({
  //             icon: InvitationLinkReactSvgUrl,
  //             id,
  //             key: `external-link_${id}`,
  //             label: title,
  //             onClick: () => {
  //               copy(shareLink);
  //               toastr.success(t("Common:LinkCopySuccess"));
  //             },
  //           });
  //         }
  //       }

  //       if (!linksArray.length) {
  //         linksArray = [
  //           {
  //             id: "no-external-links-option",
  //             key: "no-external-links",
  //             label: !links.length
  //               ? t("Files:NoExternalLinks")
  //               : t("Files:AllLinksAreDisabled"),
  //             disableColor: true,
  //           },
  //           !isMobile && {
  //             key: "separator0",
  //             isSeparator: true,
  //           },
  //           {
  //             icon: SettingsReactSvgUrl,
  //             id: "manage-option",
  //             key: "manage-links",
  //             label: t("Common:ManageNotifications"),
  //             onClick: () => this.onShowInfoPanel(item, "info_members"),
  //           },
  //         ];
  //       }

  //       this.setLoaderTimer(false, () => resolve(linksArray));
  //     } catch (error) {
  //       toastr.error(error);
  //       this.setLoaderTimer(false);
  //       return reject(linksArray);
  //     }
  //   });

  //   return promise;
  // };

  onLoadPlugins = (item) => {
    const { contextOptions } = item;
    const { enablePlugins } = this.settingsStore;

    const pluginItems = [];
    this.setLoaderTimer(true);

    if (enablePlugins && this.pluginStore.contextMenuItemsList) {
      this.pluginStore.contextMenuItemsList.forEach((option) => {
        // Helper function to recursively process context menu items
        const processOptionValue = (value) => {
          if (contextOptions.includes(value.key)) {
            const onClick = async () => {
              if (value.withActiveItem) {
                const { setActiveFiles } = this.filesStore;

                setActiveFiles([item.id]);

                await value.onClick(item.id);

                setActiveFiles([]);
              } else {
                value.onClick(item.id);
              }
            };

            const processedOptionValue = {
              key: value.key,
              id: value.key,
              label: value.label,
              icon: value.icon,
              onClick,
            };

            const processedItems = [];
            // Recursively process nested items if they exist
            if (value.items && value.items.length > 0) {
              value.items.forEach((nestedItem) => {
                const processedItem = processOptionValue(nestedItem);
                processedItem && processedItems.push(processedItem);
              });

              if (processedItems.length > 0) {
                processedOptionValue.items = processedItems;
              } else {
                // If we have no processed items, we dont render this option
                return null;
              }
            }

            return processedOptionValue;
          }
        };

        const value = processOptionValue(option.value);

        value && pluginItems.push(value);
      });
    }

    this.setLoaderTimer(false);

    return pluginItems;
  };

  onClickInviteUsers = (e, roomType) => {
    const data = (e.currentTarget && e.currentTarget.dataset) || e;

    const { action } = data;

    const { isGracePeriod } = this.currentTariffStatusStore;

    if (isGracePeriod) {
      this.dialogsStore.setQuotaWarningDialogVisible(true);
    } else {
      this.dialogsStore.setInvitePanelOptions({
        visible: true,
        roomId: action || e,
        hideSelector: false,
        defaultAccess: getDefaultAccessUser(roomType),
      });
    }
  };

  onClickPin = (e, id, t) => {
    const data = (e.currentTarget && e.currentTarget.dataset) || e;
    const { action } = data;

    this.filesActionsStore.setPinAction(action, id, t);
  };

  onClickArchive = (e) => {
    const data = (e.currentTarget && e.currentTarget.dataset) || e;
    const { action } = data;
    const { isWarningRoomsDialog } = this.currentQuotaStore;
    const {
      setArchiveDialogVisible,
      setRestoreRoomDialogVisible,
      setQuotaWarningDialogVisible,
    } = this.dialogsStore;

    if (action === "unarchive" && isWarningRoomsDialog) {
      setQuotaWarningDialogVisible(true);
      return;
    }

    if (action === "archive") {
      setArchiveDialogVisible(true);
    } else {
      setRestoreRoomDialogVisible(true);
    }
  };

  onChangeRoomOwner = () => this.dialogsStore.setChangeRoomOwnerIsVisible(true);

  onLeaveRoom = () => {
    this.dialogsStore.setLeaveRoomDialogVisible(true);
  };

  onSelect = (item) => {
    const { onSelectItem } = this.filesActionsStore;

    onSelectItem({ id: item.id, isFolder: item.isFolder }, true, false);
  };

  onShowEditingToast = (t) => {
    toastr.error(t("Files:DocumentEdited"));
  };

  onShowWaitOperationToast = (t) => {
    toastr.warning(t("Files:WaitOperation"));
  };

  onClickMute = (e, item, t) => {
    const data = (e.currentTarget && e.currentTarget.dataset) || e;
    const { action } = data;

    this.filesActionsStore.setMuteAction(action, item, t);
  };

  onExportRoomIndex = (t, roomId) => {
    this.filesActionsStore.exportRoomIndex(t, roomId);
  };

  onEditIndex = () => {
    this.indexingStore.setIsIndexEditingMode(true);
  };

  onEnableFormFillingGuid = (t, roomType) => {
    const guidanceConfig = getGuidanceConfig(roomType, t);

    if (!guidanceConfig) {
      return;
    }

    this.guidanceStore.setConfig(guidanceConfig);
    this.dialogsStore.setWelcomeFormFillingTipsVisible(true);
  };

  onClickRemoveFromRecent = (item) => {
    this.filesActionsStore.removeFilesFromRecent([item.id]);
  };

  setLoaderTimer = (isLoading, cb) => {
    if (isLoading) {
      loadingTime = new Date();

      return (timer = setTimeout(() => {
        this.linksIsLoading = true;
      }, LOADER_TIMER));
    }
    if (loadingTime) {
      const currentDate = new Date();

      let ms = Math.abs(loadingTime.getTime() - currentDate.getTime());

      if (timer) {
        ms = Math.abs(ms - LOADER_TIMER);

        clearTimeout(timer);
        timer = null;
      }

      if (ms < LOADER_TIMER) {
        return setTimeout(() => {
          this.linksIsLoading = true;
          loadingTime = null;
          cb && cb();
        }, LOADER_TIMER - ms);
      }
    }

    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    loadingTime = null;
    this.linksIsLoading = false;
    cb && cb();
  };

  onCreateTemplate = async () => {
    this.oformsStore.setTemplateGalleryVisible(false);
    this.oformsStore.setIsVisibleInfoPanelTemplateGallery(false);

    const event = new Event(Events.CREATE);

    const payload = {
      extension: this.oformsStore.currentExtensionGallery.replace(".", ""),
      id: -1,
      fromTemplate: true,
      title: this.oformsStore.gallerySelected.attributes.name_form,
      openEditor: true,
      edit: true,
    };

    event.payload = payload;

    window.dispatchEvent(event);
  };

  onShowOformTemplateInfo = (item) => {
    showInfoPanel();
    this.oformsStore.setGallerySelected(item);
  };

  onSuggestOformChanges = (item) => {
    const formTitle = item.attributes ? item.attributes.name_form : item.title;

    window.location = `mailto:marketing@onlyoffice.com
    ?subject=Suggesting changes for ${formTitle}
    &body=Suggesting changes for ${formTitle}.
  `;
  };

  getFormGalleryContextOptions = (item, t, navigate) => {
    return [
      {
        key: "create",
        label: t("Common:Create"),
        onClick: () => this.onCreateTemplate(navigate),
      },
      {
        key: "template-info",
        label: t("FormGallery:TemplateInfo"),
        onClick: () => this.onShowOformTemplateInfo(item),
      },
      {
        key: "separator",
        isSeparator: true,
      },
      {
        key: "suggest-changes",
        label: t("FormGallery:SuggestChanges"),
        onClick: () => this.onSuggestOformChanges(item),
      },
    ];
  };

  getRoomsRootContextOptions = (item, t) => {
    const { id, rootFolderId } = this.selectedFolderStore;
    const isRootRoom = item.isRoom && rootFolderId === id;

    if (!isRootRoom) return { pinOptions: [], muteOptions: [] };

    const pinOptions = [
      {
        id: "option_pin-room",
        key: "pin-room",
        label: t("PinToTop"),
        icon: PinReactSvgUrl,
        onClick: (e) => this.onClickPin(e, item.id, t),
        disabled:
          this.publicRoomStore.isPublicRoom ||
          Boolean(item.external && item.isLinkExpired),
        "data-action": "pin",
        action: "pin",
      },
      {
        id: "option_unpin-room",
        key: "unpin-room",
        label: t("Unpin"),
        icon: UnpinReactSvgUrl,
        onClick: (e) => this.onClickPin(e, item.id, t),
        disabled:
          this.publicRoomStore.isPublicRoom ||
          Boolean(item.external && item.isLinkExpired),
        "data-action": "unpin",
        action: "unpin",
      },
    ];

    const canMute = item.security?.Mute && !this.publicRoomStore.isPublicRoom;

    const muteOptions = [
      {
        id: "option_unmute-room",
        key: "unmute-room",
        label: t("EnableNotifications"),
        icon: UnmuteReactSvgUrl,
        onClick: (e) => this.onClickMute(e, item, t),
        disabled: !canMute,
        "data-action": "unmute",
        action: "unmute",
      },
      {
        id: "option_mute-room",
        key: "mute-room",
        label: t("DisableNotifications"),
        icon: MuteReactSvgUrl,
        onClick: (e) => this.onClickMute(e, item, t),
        disabled: !canMute,
        "data-action": "mute",
        action: "mute",
      },
    ];

    return { pinOptions, muteOptions };
  };

  onEmptyTrashAction = () => {
    const { activeFiles, activeFolders } = this.filesStore;
    const isExistActiveItems = [...activeFiles, ...activeFolders].length > 0;

    if (isExistActiveItems || this.filesActionsStore.emptyTrashInProgress)
      return;

    this.dialogsStore.setEmptyTrashDialogVisible(true);
  };

  onEmptyPersonalAction = () => {
    if (this.filesActionsStore.emptyPersonalRoomInProgress) return;

    this.dialogsStore.setEmptyTrashDialogVisible(true);
  };

  onRestoreAllAction = () => {
    const { activeFiles, activeFolders } = this.filesStore;
    const isExistActiveItems = [...activeFiles, ...activeFolders].length > 0;

    if (isExistActiveItems) return;

    this.dialogsStore.setRestoreAllPanelVisible(true);
  };

  onRestoreAllArchiveAction = () => {
    const { activeFiles, activeFolders } = this.filesStore;
    const {
      setQuotaWarningDialogVisible,
      setRestoreAllArchive,
      setRestoreRoomDialogVisible,
    } = this.dialogsStore;

    const isExistActiveItems = [...activeFiles, ...activeFolders].length > 0;

    if (isExistActiveItems) return;

    if (this.currentQuotaStore.isWarningRoomsDialog) {
      setQuotaWarningDialogVisible(true);
      return;
    }

    setRestoreAllArchive(true);
    setRestoreRoomDialogVisible(true);
  };

  onDownloadAllAction = () => {
    const { getSelectedFolder } = this.selectedFolderStore;
    const { downloadAction } = this.filesActionsStore;

    const selectedFolder = getSelectedFolder();

    downloadAction("", selectedFolder).catch((err) => toastr.error(err));
  };

  createMenuGroup = (options, groupConfig, t) => {
    const {
      groupKey,
      groupLabel,
      groupIcon,
      itemKeys,
      needsGrouping = false,
      minItemsCount = 1,
    } = groupConfig;

    let groupItems = [];

    if (needsGrouping) {
      let lastNonEmptyGroupIndex = -1;

      itemKeys.forEach((group, groupIndex) => {
        const groupSubItems = group
          .map((groupItem) =>
            options.find((option) => option.key === groupItem.key),
          )
          .filter((menuItem) => menuItem && menuItem.disabled !== true);

        if (groupSubItems.length > 0) {
          if (lastNonEmptyGroupIndex !== -1) {
            groupItems.push({
              key: `separator-after-group-${lastNonEmptyGroupIndex}`,
              isSeparator: true,
            });
          }

          groupSubItems.forEach((menuItem) => groupItems.push(menuItem));
          lastNonEmptyGroupIndex = groupIndex;
        }
      });
    } else {
      groupItems = itemKeys
        .map((item) =>
          options.find(
            (option) =>
              option.key === (typeof item === "object" ? item.key : item),
          ),
        )
        .filter((option) => option && option.disabled !== true);
    }

    const itemsCount = groupItems.filter(
      (menuItem) => !menuItem.isSeparator && menuItem.disabled !== true,
    ).length;

    const shouldAddGroup = itemsCount > minItemsCount;

    return {
      group: shouldAddGroup
        ? {
            id: `option_${groupKey}`,
            key: groupKey,
            label: t(groupLabel),
            icon: groupIcon,
            items: groupItems,
          }
        : null,
      keysToRemove: shouldAddGroup
        ? needsGrouping
          ? itemKeys.flat().map((item) => item.key)
          : itemKeys.map((item) => (typeof item === "object" ? item.key : item))
        : [],
    };
  };

  getHeaderOptions = (t, item) => {
    const {
      isRecycleBinFolder,
      isArchiveFolder,
      isTemplatesFolder,
      isPersonalReadOnly,
    } = this.treeFoldersStore;
    const { roomsForDelete, roomsForRestore } = this.filesStore;

    const canRestoreAll = roomsForRestore.length > 0;
    const canDeleteAll = roomsForDelete.length > 0;

    if (this.publicRoomStore.isPublicRoom) {
      return [
        {
          key: "public-room_share",
          label: t("Common:CopySharedLink"),
          icon: TabletLinkReactSvgUrl,
          onClick: () => {
            copy(window.location.href);
            toastr.success(t("Common:LinkCopySuccess"));
          },
          disabled: this.settingsStore.isFrame,
        },
        {
          key: "separator0",
          isSeparator: true,
          disabled: !item.security?.Download || this.settingsStore.isFrame,
        },
        {
          key: "public-room_edit",
          label: t("Common:Download"),
          icon: DownloadReactSvgUrl,
          onClick: () => {
            this.onClickDownload(item, t);
          },
          disabled: !item.security?.Download,
        },
      ];
    }

    if (isRecycleBinFolder) {
      return [
        {
          id: "header_option_empty-trash",
          key: "empty-trash",
          label: t("Files:EmptySection", {
            sectionName: t("Common:TrashSection"),
          }),
          onClick: this.onEmptyTrashAction,
          icon: ClearTrashReactSvgUrl,
          disabled: false,
        },
        {
          id: "header_option_restore-all",
          key: "restore-all",
          label: t("RestoreAll"),
          onClick: this.onRestoreAllAction,
          icon: MoveReactSvgUrl,
          disabled: false,
        },
      ];
    }

    if (isArchiveFolder) {
      return [
        {
          id: "header_option_empty-archive",
          key: "empty-archive",
          label: t("ArchiveAction"),
          onClick: this.onEmptyTrashAction,
          disabled: !canDeleteAll,
          icon: ClearTrashReactSvgUrl,
        },
        {
          id: "header_option_restore-all",
          key: "restore-all",
          label: t("RestoreAll"),
          onClick: this.onRestoreAllArchiveAction,
          disabled: !canRestoreAll,
          icon: MoveReactSvgUrl,
        },
      ];
    }

    if (isTemplatesFolder) {
      return [];
    }

    if (isPersonalReadOnly) {
      return [
        {
          id: "header_option_download-all",
          key: "download-all",
          label: t("Files:DownloadAll"),
          onClick: this.onDownloadAllAction,
          icon: MoveReactSvgUrl,
          disabled: false,
        },
        {
          id: "header_option_empty-section",
          key: "empty-section",
          label: t("Files:EmptySection", {
            sectionName: t("Common:MyDocuments"),
          }),
          onClick: this.onEmptyPersonalAction,
          icon: ClearTrashReactSvgUrl,
          disabled: false,
        },
      ];
    }

    return this.getFilesContextOptions(item, t, false, true);
  };

  handleCopyPrimaryLink = async (item, t) => {
    if (!item.canShare) return;

    const primaryLink = await ShareLinkService.getPrimaryLink(item);

    if (primaryLink) {
      copyShareLink(item, primaryLink, t, this.getManageLinkOptions(item));
      this.infoPanelStore?.setShareChanged(true);
    }
  };

  getManageLinkOptions = (item) => {
    const isRoom = isRoomUtil(item);

    const openTab = () => {
      if (isRoom) return openMembersTab();

      openShareTab();
    };

    const infoView = isRoom
      ? this.infoPanelStore.roomsView
      : this.infoPanelStore.fileView;

    const { infoPanelSelection } = this.infoPanelStore;

    return {
      canShowLink: canShowManageLink(
        item,
        infoPanelSelection,
        getInfoPanelOpen(),
        infoView,
      ),
      onClickLink: () => {
        this.filesStore.setSelection([]);
        this.filesStore.setBufferSelection(item);
        openTab();
      },
    };
  };

  getFilesContextOptions = (item, t, isInfoPanel, isHeader) => {
    const optionsToRemove = isInfoPanel
      ? ["select", "open", "room-info", "show-info"]
      : isHeader
        ? ["select"]
        : [];

    if (!item.contextOptions) {
      const contextOptions = this.filesStore.getFilesContextOptions(
        item,
        optionsToRemove,
      );
      item = { ...item, contextOptions };
    } else {
      item.contextOptions = removeOptions(item.contextOptions, optionsToRemove);
    }

    const { isPublicRoom } = this.publicRoomStore;

    const { contextOptions, isEditing } = item;

    const isRootThirdPartyFolder =
      item.providerKey && item.id === item.rootFolderId;

    // const isShareable = this.treeFoldersStore.isPersonalRoom
    //   ? item.canShare || (item.isFolder && item.security?.CreateRoomFrom)
    //   : false;

    const isMedia =
      item.viewAccessibility?.ImageView || item.viewAccessibility?.MediaView;

    const hasInfoPanel = contextOptions.includes("show-info");

    // const emailSendIsDisabled = true;
    const showSeparator0 =
      hasInfoPanel || !isMedia || (item.external && item.isLinkExpired); // || !emailSendIsDisabled;

    const separator0 = showSeparator0
      ? {
          key: "separator0",
          isSeparator: true,
        }
      : false;

    const onlyShowVersionHistory =
      !contextOptions.includes("finalize-version") &&
      contextOptions.includes("show-version-history");

    const versionActions = onlyShowVersionHistory
      ? [
          {
            id: "option_show-version-history",
            key: "show-version-history",
            label: t("Common:ShowVersionHistory"),
            icon: HistoryReactSvgUrl,
            onClick: () =>
              this.showVersionHistory(
                item.id,
                item.security,
                item?.requestToken,
              ),
            disabled: false,
          },
        ]
      : [
          {
            id: "option_version",
            key: "version",
            label: t("VersionHistory"),
            icon: HistoryFinalizedReactSvgUrl,
            items: [
              {
                id: "option_finalize-version",
                key: "finalize-version",
                label: t("FinalizeVersion"),
                icon: HistoryFinalizedReactSvgUrl,
                onClick: () =>
                  isEditing
                    ? this.onShowEditingToast(t)
                    : this.finalizeVersion(item.id, item.security),
                disabled: false,
              },
              {
                id: "option_version-history",
                key: "show-version-history",
                label: t("Common:ShowVersionHistory"),
                icon: HistoryReactSvgUrl,
                onClick: () =>
                  this.showVersionHistory(
                    item.id,
                    item.security,
                    item?.requestToken,
                  ),
                disabled: false,
              },
            ],
          },
        ];

    const moveActions = [
      {
        id: "option_move-or-copy",
        key: "move",
        label: t("MoveOrCopy"),
        icon: CopyReactSvgUrl,
        items: [
          {
            id: "option_move-to",
            key: "move-to",
            label: t("Common:MoveTo"),
            icon: MoveReactSvgUrl,
            onClick: isEditing
              ? () => this.onShowEditingToast(t)
              : () => this.onMoveAction(item),
            disabled: false,
          },
          {
            id: "option_copy-to",
            key: "copy-to",
            label: t("Common:Copy"),
            icon: CopyReactSvgUrl,
            onClick: () => this.onCopyAction(item),
            disabled: false,
          },
          {
            id: "option_create-duplicate",
            key: "duplicate",
            label: t("Common:Duplicate"),
            icon: DuplicateReactSvgUrl,
            onClick: () => this.onDuplicate(item, t),
            disabled: false,
          },
        ],
      },
    ];

    const { pinOptions, muteOptions } = this.getRoomsRootContextOptions(
      item,
      t,
    );

    let withOpen = item.id !== this.selectedFolderStore.id;
    const isPublicRoomType =
      item.roomType === RoomsType.PublicRoom ||
      item.roomType === RoomsType.FormRoom ||
      item.roomType === RoomsType.CustomRoom;

    const { navigationPath } = this.selectedFolderStore;

    if (item.isRoom && withOpen) {
      withOpen = navigationPath.findIndex((f) => f.id === item.id) === -1;
    }

    const isArchive = item.rootFolderType === FolderType.Archive;
    const isFormRoom = item.roomType === RoomsType.FormRoom;

    const hasShareLinkRights = isPublicRoom
      ? item.security?.Read
      : item.shared
        ? item.security.CopySharedLink
        : item.security?.EditAccess;

    const { isFiltered } = this.filesStore;
    const { isIndexedFolder, security } = this.selectedFolderStore;

    const indexOptions = {
      id: "option_edit-index",
      key: "edit-index",
      label: t("Common:EditIndex"),
      icon: EditIndexReactSvgUrl,
      onClick: () => this.onEditIndex(),
      disabled: !security?.EditRoom || !isIndexedFolder || isFiltered,
    };

    const isTemplateOwner =
      item.access === ShareAccessRights.None ||
      item.access === ShareAccessRights.FullAccess;

    const isRoomAdmin =
      item.access === ShareAccessRights.RoomManager ||
      item.access === ShareAccessRights.None;

    const optionsModel = [
      {
        id: "option_select",
        key: "select",
        label: t("Common:SelectAction"),
        icon: CheckBoxReactSvgUrl,
        onClick: () => this.onSelect(item),
        disabled: false,
      },
      withOpen && {
        id: "option_open",
        key: "open",
        label: t("Open"),
        icon: FolderReactSvgUrl,
        onClick: () => this.onOpenFolder(item, t),
        disabled: Boolean(item.external && item.isLinkExpired),
      },
      {
        id: "option_fill-form",
        key: "fill-form",
        label: t("Common:FillFormButton"),
        icon: FormFillRectSvgUrl,
        onClick: () => this.onClickLinkFillForm(item),
        disabled: false,
      },
      {
        id: "option_open-pdf",
        key: "open-pdf",
        label: t("Open"),
        icon: EyeReactSvgUrl,
        onClick: () => this.gotoDocEditor(item, false),
        disabled: false,
      },
      {
        id: "option_edit-pdf",
        key: "edit-pdf",
        label: t("Common:EditButton"),
        icon: AccessEditReactSvgUrl,
        onClick: () => {
          if (isMobile) {
            toastr.info(t("Common:MobileEditPdfNotAvailableInfo"));
            return;
          }
          this.onOpenPDFEditDialog(item.id);
        },
        disabled: false,
      },
      {
        id: "option_edit",
        key: "edit",
        label: t("Common:EditButton"),
        icon: AccessEditReactSvgUrl,
        onClick: () => {
          const isPDF = item.fileExst === ".pdf";

          if (isPDF && isMobile) {
            toastr.info(t("Common:MobileEditPdfNotAvailableInfo"));
            return;
          }
          this.onClickLinkEdit(item);
        },
        disabled: false,
      },
      {
        id: "option_preview",
        key: "preview",
        label: t("Common:Preview"),
        icon: EyeReactSvgUrl,
        onClick: () => this.onPreviewClick(item),
        disabled: false,
      },
      {
        id: "option_view",
        key: "view",
        label: t("Common:View"),
        icon: EyeReactSvgUrl,
        onClick: (fileId) => this.onMediaFileClick(fileId, item),
        disabled: false,
      },
      {
        id: "option_pdf-view",
        key: "pdf-view",
        label: "Pdf viewer",
        icon: EyeReactSvgUrl,
        onClick: (fileId) => this.onMediaFileClick(fileId, item),
        disabled: false,
      },
      {
        id: "option_make-form",
        key: "make-form",
        label: t("Common:MakeForm"),
        icon: FormPlusReactSvgUrl,
        onClick: () => this.onClickMakeForm(item, t),
        disabled: false,
      },
      ...pinOptions,
      ...muteOptions,
      separator0,
      {
        id: "option_submit-to-gallery",
        key: "submit-to-gallery",
        label: t("Common:SubmitToTemplateGallery"),
        icon: FormFileReactSvgUrl,
        onClick: () => this.onClickSubmitToFormGallery(item),
        isOutsideLink: true,
        disabled: !item.security?.SubmitToFormGallery,
      },
      {
        id: "option_start-filling",
        key: "start-filling",
        label: t("Common:StartFilling"),
        icon: FormFillRectSvgUrl,
        onClick: () => this.onClickStartFilling(item, t),
        disabled: false,
      },
      {
        id: "option_reset-and-start-filling",
        key: "reset-and-start-filling",
        label: t("Common:ResetAndStartFilling"),
        icon: BackupSvgUrl,
        onClick: () => this.onClickResetAndStartFilling(item),
        disabled: false,
      },
      {
        id: "option_filling-status",
        key: "filling-status",
        label: t("Common:FillingStatus"),
        icon: FormFillRectSvgUrl,
        onClick: () => this.onFillingStatus(item),
        disabled: false,
      },
      {
        key: "separator-SubmitToGallery",
        isSeparator: true,
      },
      {
        key: "separator4",
        isSeparator: true,
      },
      {
        id: "option_create-room",
        key: "create-room-from-template",
        label: t("Common:CreateRoom"),
        icon: CreateRoomReactSvgUrl,
        onClick: () => this.filesActionsStore.onCreateRoomFromTemplate(item),
        disabled: false,
      },
      {
        id: "option_edit-room",
        key: "edit-room",
        label: t("EditRoom"),
        icon: SettingsReactSvgUrl,
        onClick: () => this.onClickEditRoom(item),
        disabled: false,
      },
      {
        id: "option_edit-room",
        key: "edit-template",
        label: t("EditTemplate"),
        icon: SettingsReactSvgUrl,
        onClick: () => this.onEditRoomTemplate(item),
        disabled: !isTemplateOwner,
      },
      {
        id: "option_save-as-template",
        key: "save-as-template",
        label: t("SaveAsTemplate"),
        icon: CreateTemplateSvgUrl,
        onClick: () => this.onSaveAsTemplate(item),
        disabled: !item.security?.Create || item.providerKey,
      },
      {
        id: "option_download",
        key: "download",
        label: t("Common:Download"),
        icon: DownloadReactSvgUrl,
        onClick: () => {
          if (isLockedSharedRoom(item))
            return this.dialogsStore.setPasswordEntryDialog(true, item, true);

          this.onClickDownload(item, t);
        },
        disabled:
          (!item.security?.Download && !isLockedSharedRoom(item)) ||
          Boolean(item.external && item.isLinkExpired),
      },
      {
        id: "option_create-duplicate-room",
        key: "duplicate-room",
        label: t("Common:Duplicate"),
        icon: DuplicateReactSvgUrl,
        onClick: () => this.onDuplicate(item, t),
        disabled: !item.security?.Duplicate,
      },
      {
        id: "option_change-room-owner",
        key: "change-room-owner",
        label: t("Files:ChangeTheRoomOwner"),
        icon: ReconnectSvgUrl,
        onClick: this.onChangeRoomOwner,
        disabled: false,
      },
      {
        id: "option_reconnect-storage",
        key: "reconnect-storage",
        label: t("Common:ReconnectStorage"),
        icon: ReconnectSvgUrl,
        onClick: () => this.onClickReconnectStorage(item, t),
        disabled: !item.security?.Reconnect || !item.security?.EditRoom,
      },
      {
        id: "option_export-room-index",
        key: "export-room-index",
        label: t("Files:ExportRoomIndex"),
        icon: ExportRoomIndexSvgUrl,
        onClick: () => this.onExportRoomIndex(t, item.id),
        disabled: !item.indexing || !item.security?.IndexExport,
      },
      {
        id: "option_access-settings",
        key: "access-settings",
        label: t("AccessSettings"),
        icon: PersonReactSvgUrl,
        onClick: () => this.onOpenTemplateAccessOptions(),
        disabled: !isTemplateOwner,
      },
      {
        id: "option_invite-users-to-room",
        key: "invite-users-to-room",
        label: t("Common:InviteContacts"),
        icon: PersonReactSvgUrl,
        onClick: (e) => this.onClickInviteUsers(e, item.roomType),
        disabled: false,
        action: item.id,
      },
      // {
      //   id: "option_copy-general-link",
      //   key: "copy-general-link",
      //   label: t("Common:CopySharedLink"),
      //   icon: TabletLinkReactSvgUrl,
      //   disabled: !isShareable,
      //   onClick: () => this.getManageLink(item, t),
      // },
      {
        id: "option_copy-shared-link",
        key: "copy-shared-link",
        label: t("Common:CopySharedLink"),
        icon: TabletLinkReactSvgUrl,
        onClick: () => this.handleCopyPrimaryLink(item, t),
        disabled: !item.canShare,
      },
      {
        id: "option_manage-links",
        key: "manage-links",
        label: t("Common:ManageShare"),
        icon: SettingsReactSvgUrl,
        onClick: () => this.onClickShare(item),
        disabled: !item.canShare,
      },
      {
        id: "option_link-for-room-members",
        key: "link-for-room-members",
        label: t("Common:CopyLink"),
        icon: InvitationLinkReactSvgUrl,
        onClick: () => this.onCopyLink(item, t),
        disabled: item.isTemplate
          ? false
          : (isPublicRoomType && hasShareLinkRights) ||
            Boolean(
              item.external && (item.isLinkExpired || item.passwordProtected),
            ),
      },
      {
        id: "option_copy-external-link",
        key: "external-link",
        label: t("Common:CopySharedLink"),
        icon: TabletLinkReactSvgUrl,
        disabled:
          !hasShareLinkRights || Boolean(item.external && item.isLinkExpired),
        onClick: () => this.onCreateAndCopySharedLink(item, t),
        // onLoad: () => this.onLoadLinks(t, item),
      },
      {
        id: "option_embedding-setting",
        key: "embedding-settings",
        label: t("Common:Embed"),
        icon: CodeReactSvgUrl,
        onClick: () => this.onOpenEmbeddingSettings(item),
        disabled: !item.security?.Embed,
      },
      {
        key: "create-room-separator",
        isSeparator: true,
        disabled: !item.security?.CreateRoomFrom,
      },
      {
        id: "option_create_room",
        key: "create-room",
        label: t("Common:CreateRoom"),
        icon: CatalogRoomsReactSvgUrl,
        onClick: () => this.onCreateRoom(item, true),
        disabled: !item.security?.CreateRoomFrom,
      },
      {
        id: "option_room-info",
        key: "room-info",
        label: t("Common:Info"),
        icon: InfoOutlineReactSvgUrl,
        onClick: () => this.onShowInfoPanel(item),
        disabled: isPublicRoom || Boolean(item.external && item.isLinkExpired),
      },
      {
        id: "option_owner-change",
        key: "owner-change",
        label: t("Translations:OwnerChange"),
        icon: FileActionsOwnerReactSvgUrl,
        onClick: this.onOwnerChange,
        disabled: false,
      },
      {
        id: "option_link-for-portal-users",
        key: "link-for-portal-users",
        label: t("LinkForPortalUsers", {
          productName: t("Common:ProductName"),
        }),
        icon: InvitationLinkReactSvgUrl,
        onClick: () => this.onClickLinkForPortal(item, t),
        disabled: false,
      },
      // {
      //   id: "option_send-by-email",
      //   key: "send-by-email",
      //   label: t("SendByEmail"),
      //   icon: MailReactSvgUrl,
      //   disabled: emailSendIsDisabled,
      // },

      {
        id: "option_show-info",
        key: "show-info",
        label: t("Common:Info"),
        icon: InfoOutlineReactSvgUrl,
        onClick: () => this.onShowInfoPanel(item),
        disabled: false,
      },
      ...versionActions,
      {
        id: "option_custom-filter",
        key: "custom-filter",
        label: item.customFilterEnabled
          ? t("Files:CustomFilterDisable")
          : t("Files:CustomFilterEnable"),
        icon: CustomFilterReactSvgUrl,
        onClick: () => this.onSetUpCustomFilter(item, t),
        disabled: Boolean(
          !isRoomAdmin &&
            item.customFilterEnabled &&
            item.customFilterEnabledBy &&
            item.customFilterEnabledBy !== this.userStore?.user?.displayName,
        ),
      },
      {
        id: "option_block-unblock-version",
        key: "block-unblock-version",
        label: item.locked ? t("Common:UnblockFile") : t("Common:BlockFile"),
        icon: LockedReactSvgUrl,
        onClick: () => this.lockFile(item, t),
        disabled: false,
      },
      {
        key: "separator1",
        isSeparator: true,
      },
      {
        id: "option_open-location",
        key: "open-location",
        label: t("OpenLocation"),
        icon: FolderLocationReactSvgUrl,
        onClick: () => this.onOpenLocation(item),
        disabled: !!item.requestToken,
      },
      {
        id: "option_mark-read",
        key: "mark-read",
        label: t("MarkRead"),
        icon: TickRoundedSvgUrl,
        onClick: () => this.onClickMarkRead(item),
        disabled: false,
      },
      {
        id: "option_mark-as-favorite",
        key: "mark-as-favorite",
        label: t("MarkAsFavorite"),
        icon: FavoritesReactSvgUrl,
        onClick: (e) => this.onClickFavorite(e, [item], t),
        disabled: false,
        "data-action": "mark",
        action: "mark",
      },
      {
        id: "option_create-duplicate-room",
        key: "duplicate-room",
        label: t("Common:Duplicate"),
        icon: DuplicateReactSvgUrl,
        onClick: () => this.onDuplicate(item, t),
        disabled: !item.security?.Duplicate,
      },
      {
        id: "option_remove-shared-room",
        key: "remove-shared-room",
        label: t("Common:RemoveFromList"),
        icon: CircleCrossSvgUrl,
        onClick: () => this.onRemoveSharedFilesOrFolder([item]),
        disabled: this.userStore?.user?.isAdmin || !item.external,
      },
      {
        id: "option_download-as",
        key: "download-as",
        label: t("Common:DownloadAs"),
        icon: DownloadAsReactSvgUrl,
        onClick: this.onClickDownloadAs,
        disabled: !item.security?.Download,
      },
      ...moveActions,
      {
        id: "option_restore",
        key: "restore",
        label: t("Common:Restore"),
        icon: MoveReactSvgUrl,
        onClick: this.onRestoreAction,
        disabled: false,
      },
      indexOptions,
      {
        id: "option_rename",
        key: "rename",
        label: t("Common:Rename"),
        icon: RenameReactSvgUrl,
        onClick: () => this.onClickRename(item),
        disabled: false,
      },
      {
        key: "separator3",
        isSeparator: true,
      },
      {
        id: "option_unsubscribe",
        key: "unsubscribe",
        label: t("Common:RemoveFromList"),
        icon: RemoveSvgUrl,
        onClick: this.onClickUnsubscribe,
        disabled: false,
      },
      {
        id: "option_change-thirdparty-info",
        key: "change-thirdparty-info",
        label: t("Translations:ThirdPartyInfo"),
        icon: AccessEditReactSvgUrl,
        onClick: () => this.onChangeThirdPartyInfo(item.providerKey),
        disabled: false,
      },
      {
        id: "option_short-tour",
        key: "short-tour",
        label: t("FormFillingTipsDialog:WelcomeStartTutorial"),
        icon: HelpCenterReactSvgUrl,
        onClick: () => this.onEnableFormFillingGuid(t, item.roomType),
        disabled:
          isArchive ||
          !isFormRoom ||
          isMobileUtils() ||
          item.id !== this.selectedFolderStore.id,
      },
      {
        id: "option_leave-room",
        key: "leave-room",
        label: t("LeaveTheRoom"),
        icon: LeaveRoomSvgUrl,
        onClick: this.onLeaveRoom,
        disabled:
          isArchive || !item.inRoom || isPublicRoom || Boolean(item.external),
      },
      {
        id: "option_archive-room",
        key: "archive-room",
        label: t("MoveToArchive"),
        icon: RoomArchiveSvgUrl,
        onClick: (e) => this.onClickArchive(e),
        disabled: false,
        "data-action": "archive",
        action: "archive",
      },
      {
        id: "option_unarchive-room",
        key: "unarchive-room",
        label: t("Common:Restore"),
        icon: MoveReactSvgUrl,
        onClick: (e) => this.onClickArchive(e),
        disabled: false,
        "data-action": "unarchive",
        action: "unarchive",
      },
      {
        key: "separator5",
        isSeparator: true,
      },
      {
        id: "option_remove-from-favorites",
        key: "remove-from-favorites",
        label: t("RemoveFromFavorites"),
        icon: FavoritesFillReactSvgUrl,
        onClick: (e) => this.onClickFavorite(e, [item], t),
        disabled: false,
        "data-action": "remove",
        action: "remove",
      },
      {
        id: "option_delete",
        key: "delete",
        label: isRootThirdPartyFolder
          ? t("Common:Disconnect")
          : item.isTemplate
            ? t("DeleteTemplate")
            : item.isRoom
              ? t("Common:DeleteRoom")
              : t("Common:Delete"),
        icon: item.isRoom ? RemoveOutlineSvgUrl : TrashReactSvgUrl,
        onClick: () => this.onDelete(item, t),
        disabled: item.isTemplate ? !isTemplateOwner : false,
      },
      {
        id: "option_remove-from-recent",
        key: "remove-from-recent",
        label: t("Common:RemoveFromList"),
        icon: RemoveOutlineSvgUrl,
        onClick: () => this.onClickRemoveFromRecent(item),
        disabled: !this.treeFoldersStore.isRecentFolder,
      },
      {
        id: "option_remove-shared-file-or-folder",
        key: "remove-shared-folder-or-file",
        label: t("Common:RemoveFromList"),
        icon: CircleCrossSvgUrl,
        onClick: () => {
          this.dialogsStore.setUnsubscribe(true);
          this.dialogsStore.setDeleteDialogVisible(true);
        },
        disabled:
          // FIXME: temporary hack  backend should expose a flag to disable this
          typeof window !== "undefined"
            ? !window?.location?.pathname.includes(SHARED_WITH_ME_PATH)
            : false,
      },
      {
        key: "separate-stop-filling",
        isSeparator: true,
      },
      {
        id: "option_stop-filling",
        key: "stop-filling",
        label: t("Common:StopFilling"),
        icon: AccessNoneReactSvgUrl,
        onClick: () =>
          this.dialogsStore.setStopFillingDialogVisible(true, item.id),
        disabled: false,
      },
    ];
    const options = this.filterModel(optionsModel, contextOptions);

    const pluginItems = this.onLoadPlugins(item);

    if (pluginItems.length > 0) {
      if (pluginItems.length === 1) {
        const plugin = pluginItems[0];
        options.splice(1, 0, {
          id: `option_${plugin.key}`,
          key: plugin.key,
          label: plugin.label,
          icon: plugin.icon,
          disabled: false,
          onClick: plugin.onClick,
          items: plugin.items,
        });
      } else {
        options.splice(1, 0, {
          id: "option_plugin-actions",
          key: "plugin_actions",
          label: t("Common:Actions"),
          icon: PluginActionsSvgUrl,
          disabled: false,
          onLoad: () => this.onLoadPlugins(item),
        });
      }
    }

    const { isCollaborator } = this.userStore?.user || {
      isCollaborator: false,
    };

    let newOptions = options.filter(
      (option, index) =>
        !(index === 0 && option.key === "separator1") &&
        !(isCollaborator && option.key === "create-room"),
    );

    const menuGroupsConfig = [
      {
        groupKey: "manage",
        groupLabel: t("Common:Manage"),
        groupIcon: SettingsReactSvgUrl,
        itemKeys: [
          [{ key: "edit-room" }, { key: "save-as-template" }],
          [{ key: "download" }, { key: "duplicate-room" }],
          [
            { key: "change-room-owner" },
            { key: "reconnect-storage" },
            { key: "export-room-index" },
          ],
        ],
        needsGrouping: true,
        minItemsCount: 1,
      },
      {
        groupKey: "share",
        groupLabel: t("Common:Share"),
        groupIcon: ShareReactSvgUrl,
        itemKeys: [
          "invite-users-to-room",
          "copy-shared-link",
          "manage-links",
          "link-for-room-members",
          "external-link",
          "embedding-settings",
          "create-room-separator",
          "create-room",
        ],
        minItemsCount: 1,
      },
    ];

    const downloadOption = newOptions.find(
      (option) => option.key === "download",
    );
    const downloadAsOption = newOptions.find(
      (option) => option.key === "download-as",
    );

    if (downloadOption && downloadAsOption) {
      const originalDownloadOption = {
        ...downloadOption,
        key: "download-original",
        label: t("Common:OriginalFormat"),
      };

      newOptions = [
        ...newOptions.filter((option) => option.key !== "download"),
        originalDownloadOption,
      ];

      menuGroupsConfig.push({
        groupKey: "download",
        groupLabel: downloadOption.label,
        groupIcon: downloadOption.icon,
        itemKeys: ["download-original", "download-as"],
        needsGrouping: false,
        minItemsCount: 1,
      });
    }

    const showInfoOption = newOptions.find(
      (option) => option.key === "show-info",
    );
    const showVersionHistoryOption = newOptions.find(
      (option) => option.key === "show-version-history",
    );

    if (showInfoOption && showVersionHistoryOption) {
      menuGroupsConfig.push({
        groupKey: "info",
        groupLabel: t("InfoPanel:Properties"),
        groupIcon: ViewRowsReactSvgUrl,
        itemKeys: ["show-info", "show-version-history"],
        needsGrouping: false,
        minItemsCount: 1,
      });
    }

    let menuGroups = [];
    let keysToRemove = [];

    menuGroupsConfig.forEach((configItem) => {
      const { group, keysToRemove: groupKeysToRemove } = this.createMenuGroup(
        newOptions,
        configItem,
        t,
      );
      if (group) {
        menuGroups.push(group);
      }
      if (groupKeysToRemove && groupKeysToRemove.length > 0) {
        keysToRemove = [...keysToRemove, ...groupKeysToRemove];
      }
    });

    if (downloadOption && downloadAsOption) {
      keysToRemove.push("download-original");
    }

    const hasCopySharedLink = newOptions.some(
      (option) => option.key === "copy-shared-link",
    );
    const linkForRoomMembers = newOptions.some(
      (option) => option.key === "link-for-room-members",
    );

    if (hasCopySharedLink && linkForRoomMembers && menuGroups.length > 0) {
      menuGroups = menuGroups.map((group) => {
        if (group.key === "share" && Array.isArray(group.items)) {
          const items = group.items.filter(
            (i) => i.key !== "link-for-room-members",
          );
          return { ...group, items };
        }
        return group;
      });
    }

    const resultOptions = newOptions.filter(
      (option) => !keysToRemove.includes(option.key),
    );

    const separatorIndex = resultOptions.findIndex(
      (option) => option.key === "separator0",
    );
    const insertIndex = separatorIndex !== -1 ? separatorIndex + 1 : 1;

    if (menuGroups.length > 0) {
      resultOptions.splice(insertIndex, 0, ...menuGroups);
    }

    const downloadGroupIndex = resultOptions.findIndex(
      (option) => option.key === "download",
    );
    const moveIndex = resultOptions.findIndex(
      (option) => option.key === "move",
    );

    if (item.isFolder && !item.isRoom) {
      const groups = [
        ["select", "open"],
        ["share", "show-info"],
        [
          "mark-as-favorite",
          "mark-read",
          "link-for-room-members",
          "download",
          "move",
          "copy-to",
          "rename",
        ],
        ["restore"],
        ["remove-from-favorites", "remove-shared-folder-or-file", "delete"],
      ];

      const items = resultOptions.filter((opt) => !opt.isSeparator);
      const result = [];
      let folderSeparatorIndex = 0;

      groups.forEach((group) => {
        const groupItems = [];
        group.forEach((key) => {
          const option = items.find((opt) => opt.key === key);
          if (option) groupItems.push(option);
        });

        if (groupItems.length > 0) {
          const isDeleteGroup = group.includes("delete");
          const shouldAddSeparator =
            result.length > 0 && (groupItems.length >= 2 || isDeleteGroup);

          if (group.includes("restore")) {
            result.push({
              key: `separator${folderSeparatorIndex++}`,
              isSeparator: true,
            });
          }

          if (shouldAddSeparator) {
            result.push({
              key: `separator${folderSeparatorIndex++}`,
              isSeparator: true,
            });
          }
          result.push(...groupItems);
        }
      });

      items.forEach((option) => {
        const isInGroups = groups.flat().includes(option.key);
        if (!isInGroups) {
          if (result.length > 0 && !result[result.length - 1].isSeparator) {
            result.push({
              key: `separator${folderSeparatorIndex++}`,
              isSeparator: true,
            });
          }
          result.push(option);
        }
      });

      return trimSeparator(result);
    }

    if (downloadGroupIndex !== -1 && moveIndex !== -1) {
      // If download group is already before move, do nothing
      if (
        downloadGroupIndex < moveIndex &&
        moveIndex - downloadGroupIndex > 1
      ) {
        // If there are other items between them, move download right before move
        const downloadGroup = resultOptions.splice(downloadGroupIndex, 1)[0];
        resultOptions.splice(moveIndex - 1, 0, downloadGroup);
      } else if (downloadGroupIndex > moveIndex) {
        // If download is after move, move it before move
        const downloadGroup = resultOptions.splice(downloadGroupIndex, 1)[0];
        resultOptions.splice(moveIndex, 0, downloadGroup);
      }
    }

    return trimSeparator(resultOptions);
  };

  getGroupContextOptions = (t) => {
    const { selection, allFilesIsEditing, canConvertSelected } =
      this.filesStore;
    const { setDeleteDialogVisible } = this.dialogsStore;
    const { isRecycleBinFolder, isRoomsFolder, isArchiveFolder } =
      this.treeFoldersStore;

    const { pinRooms, unpinRooms /* deleteRooms */ } = this.filesActionsStore;

    if (isRoomsFolder || isArchiveFolder) {
      const isPinOption = selection.filter((item) => !item.pinned).length > 0;

      let canDelete;
      if (isRoomsFolder) {
        canDelete = selection.every((k) => k.contextOptions.includes("delete"));
      } else if (isArchiveFolder) {
        canDelete = selection.some((k) => k.contextOptions.includes("delete"));
      }

      const canArchiveRoom = selection.every((k) =>
        k.contextOptions.includes("archive-room"),
      );

      const canRestoreRoom = selection.some((k) =>
        k.contextOptions.includes("unarchive-room"),
      );

      let archiveOptions;

      const pinOption = isPinOption
        ? {
            key: "pin-room",
            label: t("PinToTop"),
            icon: PinReactSvgUrl,
            onClick: () => pinRooms(t),
            disabled: false,
          }
        : {
            key: "unpin-room",
            label: t("Unpin"),
            icon: UnpinReactSvgUrl,
            onClick: () => unpinRooms(t),
            disabled: false,
          };

      if (canArchiveRoom) {
        archiveOptions = {
          key: "archive-room",
          label: t("MoveToArchive"),
          icon: RoomArchiveSvgUrl,
          onClick: (e) => this.onClickArchive(e),
          disabled: false,
          "data-action": "archive",
          action: "archive",
        };
      }
      if (canRestoreRoom) {
        archiveOptions = {
          key: "unarchive-room",
          label: t("Common:Restore"),
          icon: MoveReactSvgUrl,
          onClick: (e) => this.onClickArchive(e),
          disabled: false,
          "data-action": "unarchive",
          action: "unarchive",
        };
      }

      const options = [];

      if (!isArchiveFolder) {
        options.push(pinOption);
      }

      if ((canArchiveRoom || canDelete) && !isArchiveFolder) {
        options.push({
          key: "separator0",
          isSeparator: true,
        });
      }

      options.push(archiveOptions);

      /* canDelete &&
        options.push({
          key: "delete-rooms",
          label: t("Common:Delete"),
          icon: TrashReactSvgUrl,
          onClick: () => deleteRooms(t),
        }); */

      return options;
    }

    const hasDownloadAccess =
      selection.findIndex((k) => k.security.Download) !== -1;

    /* const favoriteItems = selection.filter((k) =>
      k.contextOptions?.includes("mark-as-favorite"),
    ); */

    const canMove = selection.every((k) =>
      k.contextOptions.includes("move-to"),
    );

    const copyItems = selection.filter((k) =>
      k.contextOptions.includes("copy-to"),
    ).length;

    const restoreItems = selection.filter((k) =>
      k.contextOptions.includes("restore"),
    ).length;

    /* const removeFromFavoriteItems = selection.filter((k) =>
      k.contextOptions.includes("remove-from-favorites"),
    ); */

    const deleteItems = selection.filter((k) =>
      k.contextOptions.includes("delete"),
    ).length;

    const isRootThirdPartyFolder = selection.some(
      (x) => x.providerKey && x.id === x.rootFolderId,
    );

    const options = [
      /* {
        key: "mark-as-favorite",
        label: t("MarkAsFavorite"),
        icon: FavoritesReactSvgUrl,
        onClick: (e) => this.onClickFavorite(e, favoriteItems, t),
        disabled: !favoriteItems.length,
        "data-action": "mark",
        action: "mark",
      }, */
      {
        id: "create_room",
        key: "create-room",
        label: t("Common:CreateRoom"),
        icon: CatalogRoomsReactSvgUrl,
        onClick: () => this.onCreateRoom(null, true),
        disabled: !selection.security?.CreateRoomFrom,
      },
      {
        key: "download",
        label: t("Common:Download"),
        icon: DownloadReactSvgUrl,
        onClick: () =>
          this.filesActionsStore
            .downloadAction(t("Common:ArchivingData"))
            .catch((err) => toastr.error(err)),
        disabled: !hasDownloadAccess,
      },
      {
        key: "download-as",
        label: t("Common:DownloadAs"),
        icon: DownloadAsReactSvgUrl,
        onClick: this.onClickDownloadAs,
        disabled: !hasDownloadAccess || !canConvertSelected,
      },
      {
        key: "move-to",
        label: t("Common:MoveTo"),
        icon: MoveReactSvgUrl,
        onClick: allFilesIsEditing
          ? () => this.onShowEditingToast(t)
          : this.onMoveAction,
        disabled: isRecycleBinFolder || !canMove,
      },
      {
        key: "copy-to",
        label: t("Common:Copy"),
        icon: CopyReactSvgUrl,
        onClick: this.onCopyAction,
        disabled: isRecycleBinFolder || !copyItems,
      },
      {
        key: "restore",
        label: t("Common:Restore"),
        icon: MoveReactSvgUrl,
        onClick: this.onRestoreAction,
        disabled: !isRecycleBinFolder || !restoreItems,
      },
      {
        key: "separator1",
        isSeparator: true,
        disabled: !deleteItems || isRootThirdPartyFolder,
      },
      {
        key: "remove-from-recent",
        label: t("Common:RemoveFromList"),
        icon: RemoveOutlineSvgUrl,
        onClick: () =>
          this.filesActionsStore.onClickRemoveFromRecent(selection),
        disabled: !this.treeFoldersStore.isRecentFolder,
      },
      /* {
        key: "remove-from-favorites",
        label: t("RemoveFromFavorites"),
        icon: FavoritesFillReactSvgUrl,
        onClick: (e) => this.onClickFavorite(e, removeFromFavoriteItems, t),
        disabled: favoriteItems.length || !removeFromFavoriteItems.length,
        "data-action": "remove",
        action: "remove",
      }, */
      {
        key: "delete",
        label: t("Common:Delete"),
        icon: TrashReactSvgUrl,
        onClick: allFilesIsEditing
          ? () => this.onShowEditingToast(t)
          : () => {
              if (this.filesSettingsStore.confirmDelete) {
                setDeleteDialogVisible(true);
              } else {
                const translations = {
                  deleteFromTrash: t("Translations:TrashItemsDeleteSuccess", {
                    sectionName: t("Common:TrashSection"),
                  }),
                };

                this.filesActionsStore
                  .deleteAction(translations)
                  .catch((err) => toastr.error(err));
              }
            },
        disabled: !deleteItems || isRootThirdPartyFolder,
      },
    ];

    const { isCollaborator } = this.userStore?.user || {
      isCollaborator: false,
    };

    const newOptions = options.filter(
      (option, index) =>
        !(index === 0 && option.key === "separator1") &&
        !(isCollaborator && option.key === "create-room"),
    );

    return newOptions;
  };

  onCreateRoom = (item, fromItem) => {
    if (this.currentQuotaStore.isWarningRoomsDialog) {
      this.dialogsStore.setQuotaWarningDialogVisible(true);
      return;
    }

    if (fromItem) {
      this.filesActionsStore.setProcessCreatingRoomFromData(true);
    }

    const event = new Event(Events.ROOM_CREATE);

    if (item && item.isFolder) {
      event.title = item.title;
    }

    window.dispatchEvent(event);
  };

  onCreate = (format, t) => {
    const event = new Event(Events.CREATE);

    const isPDf = format === FileExtensions.PDF;

    if (isMobile && isPDf) {
      toastr.info(t("Common:MobileEditPdfNotAvailableInfo"));
      return;
    }

    const payload = {
      extension: format,
      id: -1,
      edit: isPDf,
    };

    event.payload = payload;

    window.dispatchEvent(event);
  };

  onCreateFormFromFile = (t) => {
    if (isMobile) {
      toastr.info(t("Common:MobileEditPdfNotAvailableInfo"));
      return;
    }

    this.dialogsStore.setSelectFileDialogVisible(true);
  };

  onShowTemplateGallery = () => {
    this.oformsStore.setTemplateGalleryVisible(true);
    this.oformsStore.setOformFromFolderId(this.selectedFolderStore.id);
  };

  // TODO: add privacy room check for files
  onUploadAction = (type) => {
    const element =
      type === "file"
        ? document.getElementById("customFileInput")
        : type === "pdf"
          ? document.getElementById("customPDFInput")
          : document.getElementById("customFolderInput");

    element?.click();
  };

  onShowFormRoomSelectFileDialog = (filter = FilesSelectorFilterTypes.DOCX) => {
    this.dialogsStore.setSelectFileFormRoomDialogVisible(true, filter, true);
  };

  getContextOptionsPlusFormRoom = (t) => {
    const uploadReadyPDFFrom = {
      id: "personal_upload-ready-Pdf-from",
      className: "main-button_drop-down_sub",
      icon: ActionsUploadReactSvgUrl,
      label: t("Common:UploadPDFForm"),
      key: "personal_upload-ready-Pdf-from",
      items: [
        {
          id: "personal_upload-from-docspace",
          className: "main-button_drop-down",
          icon: ActionsUploadReactSvgUrl,
          label: t("Common:FromPortal", {
            productName: t("Common:ProductName"),
          }),
          key: "personal_upload-from-docspace",
          onClick: () =>
            this.onShowFormRoomSelectFileDialog(FilterType.PDFForm),
        },
        {
          id: "personal_upload-from-device",
          className: "main-button_drop-down",
          icon: ActionsUploadReactSvgUrl,
          label: t("Common:FromDevice"),
          key: "personal_upload-from-device",
          onClick: () => this.onUploadAction("pdf"),
        },
      ],
    };

    const createNewFolder = {
      id: "actions_new-folder",
      className: "main-button_drop-down",
      icon: CatalogFolderReactSvgUrl,
      label: t("Files:CreateNewFolder"),
      onClick: () => this.onCreate(),
      key: "new-folder",
    };

    // const showUploadFolder = !(isMobile || isTablet);

    // const moreActions = {
    //   id: "personal_more-form",
    //   className: "main-button_drop-down",
    //   icon: PluginMoreReactSvgUrl,
    //   label: t("Common:More"),
    //   disabled: false,
    //   key: "more-form",
    //   items: [
    //     createNewFolder,
    //     {
    //       isSeparator: true,
    //       key: "personal_more-form__separator-1",
    //     },
    //     createNewDoc,
    //     createNewPresentation,
    //     createNewSpreadsheet,
    //     {
    //       isSeparator: true,
    //       key: "personal_more-form__separator-2",
    //     },
    //     uploadFiles,
    //     showUploadFolder ? uploadFolder : null,
    //   ],
    // };

    return [
      uploadReadyPDFFrom,
      // templatePDFForm,
      // {
      //   isSeparator: true,
      //   key: "separator",
      // },
      {
        isSeparator: true,
        key: "separator-1",
      },
      createNewFolder,
      // moreActions,
    ];
  };

  getFolderModel = (t, isSectionMenu) => {
    const { isLoading } = this.clientLoadingStore;
    const { security, roomType, parentRoomType, isFolder } =
      this.selectedFolderStore;
    const { isPublicRoom } = this.publicRoomStore;

    const stateCanCreate = window?.DocSpace?.location?.state?.canCreate;
    const isSettingsPage =
      window?.DocSpace?.location.pathname.includes("/settings");

    const currentCanCreate =
      isLoading &&
      hasOwnProperty(window?.DocSpace?.location?.state, "canCreate")
        ? stateCanCreate
        : security?.Create;

    const canCreate = currentCanCreate && !isSettingsPage && !isPublicRoom;

    const someDialogIsOpen = checkDialogsOpen();

    if (!canCreate || (isSectionMenu && (isMobile || someDialogIsOpen)))
      return null;

    const { isRoomsFolder, isPrivacyFolder, isFlowsFolder } =
      this.treeFoldersStore;
    const { mainButtonItemsList } = this.pluginStore;
    const { enablePlugins, templateGalleryAvailable } = this.settingsStore;
    const isFormRoomType =
      roomType === RoomsType.FormRoom ||
      (parentRoomType === FolderType.FormRoom && isFolder);

    const createNewDoc = {
      id: "personal_new-document",
      key: "new-document",
      label: t("Common:NewDocument"),
      onClick: () => this.onCreate("docx"),
      icon: ActionsDocumentsReactSvgUrl,
    };

    const createNewSpreadsheet = {
      id: "personal_new-spreadsheet",
      key: "new-spreadsheet",
      label: t("Common:NewSpreadsheet"),
      onClick: () => this.onCreate("xlsx"),
      icon: SpreadsheetReactSvgUrl,
    };

    const createNewPresentation = {
      id: "personal_new-presentation",
      key: "new-presentation",
      label: t("Common:NewPresentation"),
      onClick: () => this.onCreate("pptx"),
      icon: ActionsPresentationReactSvgUrl,
    };

    const createTemplateForm = {
      id: "personal_template_black",
      key: "new-form",
      label: t("Translations:SubNewForm"),
      icon: FormBlankReactSvgUrl,
      onClick: () => this.onCreate("pdf", t),
    };

    const createTemplateNewFormFile = {
      id: "personal_template_new-form-file",
      key: "new-form-file",
      label: t("Translations:SubNewFormFile"),
      icon: FormFileReactSvgUrl,
      onClick: () => this.onCreateFormFromFile(t),
      disabled: isPrivacyFolder,
    };

    const createTemplateSelectFormFile = {
      id: "personal_template_new-form-file",
      key: "new-form-file",
      label: t("Translations:SubNewFormFile"),
      icon: FormFileReactSvgUrl,
      onClick: () => this.onCreateFormFromFile(t),
      disabled: isPrivacyFolder,
    };

    const createNewFolder = {
      id: "personal_new-folder",
      key: "new-folder",
      label: t("Common:NewFolder"),
      onClick: () => this.onCreate(),
      icon: CatalogFolderReactSvgUrl,
    };

    const uploadFiles = {
      key: "upload-files",
      label: t("Article:UploadFiles"),
      onClick: () => this.onUploadAction("file"),
      icon: ActionsUploadReactSvgUrl,
    };

    const uploadFolder = {
      key: "upload-folder",
      label: t("Article:UploadFolder"),
      onClick: () => this.onUploadAction("folder"),
      icon: ActionsUploadReactSvgUrl,
    };

    const templateGallery = templateGalleryAvailable
      ? [
          { key: "separator", isSeparator: true },
          {
            key: "template-gallery",
            label: t("Common:TemplateGallery"),
            onClick: () => this.onShowTemplateGallery(),
            icon: TemplateGalleryReactSvgUrl,
          },
        ]
      : [];

    if (isFormRoomType) {
      return this.getContextOptionsPlusFormRoom(t, {
        createTemplateForm,
        createTemplateSelectFormFile,
        createNewFolder,
        createNewDoc,
        createNewPresentation,
        createNewSpreadsheet,
        uploadFiles,
        uploadFolder,
      });
    }

    const formActions = [
      {
        id: "personal_form-template",
        icon: FormReactSvgUrl,
        label: t("Translations:NewForm"),
        key: "new-form-base",
        items: [createTemplateForm, createTemplateNewFormFile],
      },
    ];

    const showUploadFolder = !(isMobile || isTablet);

    const options = isRoomsFolder
      ? isFlowsFolder
        ? []
        : [
            {
              key: "new-room",
              label: t("Common:NewRoom"),
              onClick: this.onCreateRoom,
              icon: CatalogRoomsReactSvgUrl,
            },
          ]
      : [
          createNewDoc,
          createNewSpreadsheet,
          createNewPresentation,
          ...formActions,
          createNewFolder,
          ...templateGallery,
          { key: "separator", isSeparator: true },
          uploadFiles,
          showUploadFolder ? uploadFolder : null,
        ];

    if (mainButtonItemsList && enablePlugins && !isRoomsFolder) {
      const pluginItems = [];

      mainButtonItemsList.forEach((option) => {
        pluginItems.push({
          key: option.key,
          ...option.value,
        });
      });

      options.splice(5, 0, {
        id: "actions_more-plugins",
        className: "main-button_drop-down",
        icon: PluginMoreReactSvgUrl,
        label: t("Common:More"),
        disabled: false,
        key: "more-plugins",
        items: pluginItems,
      });
    }

    return options;
  };

  getModel = (item, t) => {
    const { selection } = this.filesStore;

    const { contextOptions } = item;

    const contextOptionsProps =
      contextOptions && contextOptions.length > 0
        ? selection.length > 1
          ? this.getGroupContextOptions(t)
          : this.getFilesContextOptions(item, t)
        : [];

    return contextOptionsProps;
  };
}

export default ContextOptionsStore;
